	弱引用
		弱引用不会增加对象的引用数量
		弱引用是可调用的对象，返回的是被引用的对象；如果所指对象不存在了，返回 None
		WeakValueDictionary
			一种可变映射类，里面的值时对象的弱引用，被引用的对象在被当作垃圾回收后，对应的键会自动删除，所以常用来做缓存
		
		WeakSet
			保存弱引用的集合，元素没有强引用时，将其删除
			如果一个类需要知道所有的实例，创建一个WeakSet类型的类属性，保存实例的引用
		
		弱引用的局限
			基本的list和dict实例不能作为弱引用的所指对象，但是他们的子类可以
			int和tuple也不能作为弱引用的目标，甚至子类也不行
			set可以
	
	Python对不可变类型施加的把戏
		对于不可变类型(str, bytes, frozenset, tuple)，深浅复制直接返回了了被复制对象的引用
		
		共享字符串字面量
			s1 = 'ABC'
			s2 = 'ABC'
			s1 is s2 #True
			这是一种优化措施，称为驻留(interning)
			对于热门的数字也有驻留现象，
	
	小结
		1.简单的赋值不创建副本
		2.对 += 或 *= 所做的增量赋值来说，如果左边的变量绑定的是不可变对象，会创建新对象；如果是可变对象，会就地修改。
		3.为现有的变量赋予新值，不会修改之前绑定的变量。这叫重新绑定：现在变量绑定了其他对象。如果变量是之前那个对象的最后一个引用，对象会被当作垃圾回收。
		4.函数的参数以别名的形式传递，这意味着，函数可能会修改通过参数传入的可变对象。这一行为无法避免，除非在本地创建副本，或者使用不可变对象（例如，传入元组，而不传入列表）。
		5.使用可变类型作为函数参数的默认值有危险，因为如果就地修改了参数，默认值也就变了，这会影响以后使用默认值的调用。
		
		引用计数为0，对象会被销毁，如果除了循环引用之外没有其他引用，两个对象都会被销毁

第 9 章 符合Python风格的对象
	对象表示形式
		repr()    __repr__
		
			便于开发者理解的方式返回对象的字符串表示形式
		
		str()	  __str__
		
			便于用户理解的方式返回对象的字符串表示形式
		
		bytes()   __bytes__
		
			返回对象的字节序列表示形式
		
		format()  __format__
		
			使用特殊的格式代码显示对象的字符串表示形式
	
	向量类
	
	classmethod与staticmethod
		classmethod
			第一个参数是类本身(cls)
			最常见的用途是备用构造方法，如frombytes
		staticmethod
			同普通函数没有区别，只是定义在了类的内部，可能跟类的某些特性有联系
			
	格式化输出(format)
		format(data, fmt_spec) fmt_spec为格式参数
		自定义类实现format功能，需要实现__format__函数
	
	可散列的Vector
		计算散列值，最好的方法是采用 ^(异或位运算符)混合各个分量的值
		实例的散列值绝不能发生变化。使向量不可变，将属性标为只读类型
		
		def __init(self,x):
			self.__x = x
			
		@property
		def x(self):
			return self.__x
			
	Python私有属性和“受保护的”属性
		改写(name mangling): 为了避免子类意外覆盖私有属性，python中采用双下划线开头__的形式声明私有变量，__声明的变量会被存入__dict__中并命名为 _类名字__变量名字如_Student__name
		如果有意而为之，私有变量一样会被修改_Student__name = 'jack'
		
		所以，一个约定成俗的规则，就是用单下划线_name 来命名“受保护”的变量，而不是采用改写的方式
	    导入模块的时候，如果是from module import * 不会导入单下划线开头的属性，如果from mudule import _Student便可以导入
		
	使用__slots__类属性节省空间
		继承自超类的__slots__没有效果，python只会使用各个类中定义的__slots__属性
		__slots__使用元组存储，能够节省很多内存空间，__slots__的意思是告诉解释器，类中的属性都在slots中
		在类中定义 __slots__ 属性之后，实例不能再有 __slots__ 中所列名称之外的其他属性。这只是一个副作用，不是 __slots__ 存在的真正原因。不要使用__slots__ 属性禁止类的用户新增实例属性。__slots__ 是用于优化的，不是为了约束程序员。
		__slots__属性不会被继承
		
	覆盖类属性
		继承的方式，去修改类属性
		class Vector:
			typecode = 'd'
		
		class shoterVector(Vecotr):
			typecode = 'f'
		
			
		

			
		
		