多维切片和省略
	...符号是Elipsis对象的别名。Elipsis是elipsis类的单例对象
	
__iadd__ 和 __add__
   +=          +
 可变序列一般都实现了__iadd__方法, 所以+=是就地的
 
 不可变对象一般都是先生成新的对象，然后将地址指向新的对象实现肉眼上的“可变”,所以对不可变对象频繁拼接效率低下，
 str类型例外,因为cpython对其进行了优化 str初始化内存的时候, 程序为其预留了额外的可扩展空间进行增量操作,不会涉及将源字符串复制到新位置的操作
 
 经典谜题
 t = (1, 2, [30, 40])
 t[2] += [40, 50]
 
 a. t 变成 (1, 2, [30, 40, 50, 60])。
 b. 因为 tuple 不支持对它的元素赋值，所以会抛出 TypeError 异常。
 c. 以上两个都不是。 
 d. a 和 b 都是对的
 
 答案是d
 首先t[2] 入栈, 完成list的拼接, 然后赋值给t[2], 由于t是tuple类型, 所以抛出异常, 但是在栈内list的拼接操作已经完成, 报错的是赋值
 
 三教训:
	1. 不要把可变对象放在元组里面
	2. 增量赋值并不是原子操作(要么全部执行成功, 要么全部不执行)
	3. 通过dis.dis()查看python字节码, 或者在http://www.pythontutor.com 在线查看可视化的python程序执行过程
	
连贯接口:
	str 的所有方法都返回一个新对象, 所以它们可以串联起来使用
	
	
list.sort 和 sorted
list.sort返回None, 改变原列表而不产生新列表

sorted返回新列表  sorted()可接受的参数为任何形式的可迭代对象 包括不可变序列和生成器
def gen():
    for i in range(20):
	    yield random.randn(0, 50)
		
sorted(gen())  #[0, 0, 1, 2, 9, 13, 15, 16, 18, 24, 25, 29, 31, 40, 41, 42, 45, 45, 46, 49]