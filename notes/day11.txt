第 8 章 对象引用、可变性和垃圾回收

	变量不是盒子
		变量不是存储数据的盒子，而是标签
		把变量分配给某个对象，而非将对象分配给某个变量
		a = [1 ,2]
		b = a
		a.append(3)
		print(b)  #[1, 2, 3]
	
	标识、相等性和别名
		每个变量都有标识、类型和值。对象一旦创建，它的标识绝不会变；你可以把标识理
		解为对象在内存中的地址。is 运算符比较两个对象的标识；id() 函数返回对象标识的
		整数表示。
		在CPython中，id()返回对象的内存地址，但是其他python解释器肯能是别的值。相同的是，ID一定是唯一的数值标注，而且在生命周期中绝对不会变
		is 和 == 之间选择
			==比较两个对象的值(对象中保存的数据)，而is比较对象的标识
			is比==快，因为is不能重载，省去调用特殊方法的步骤而是直接比较两个整数ID值
			a==b相当于a.__eq__(b),继承自objeck的__eq__方法判断的是ID，结果和is一样
		
		元组的相对不可变性
			元组和多数的python集合(列表，字典，集，等等)一样，保存的是对象的引用，而str、bytes和array.array等单一序列是扁平的，保存的是数据本身
	
	默认浅复制
		a = [1, 2, 3]
		b = a[:] 
		做的是浅复制
		浅复制复制的是内存引用
		
		deepcopy
			复制
			防止循环引用
			
		__copy__控制浅复制行为
		__deepcopy__控制深复制行为
		
	函数的参数作为引用时
		Python唯一支持的参数传递模式是共享传参(call by sharing): 函数的各个形式参数获得实参中各个引用的副本，函数内部的形参是实参的别名
		shican = 10
		def fun(xingcan):
			#xingcan是shican的别名
			print(xingcan)
		fun(shican)
		函数可能会修改可变对象，如list
		不要把可变类型作为参数默认值
			def func(a = []):
				a.append(1)
				return a
			func() #[1]
			func() #[1, 1]
			第二次调用时默认列表不为空
		
		防止意外修改可变参数
		
	del 与垃圾回收
		Cpython采用引用计数的方式回收对象。当引用归零时，对象会被销毁
			
			
